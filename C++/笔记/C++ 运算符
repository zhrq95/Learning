双目运算符中，若两个操作数的类型不一致，则会在计算前进行类型提升：
精度低的类型向精度高的类型提升;
范围低的类型向范围高的类型提升。

一、算术运算符
需要先引入数学函数库 #include

1、加法运算
x=+y 相当于 x=1*y ，即：正y

2、减法运算
x=-y 相当于 x=(-1)*y ，即：负y

3、乘法运算

4、除法运算
以 x=a/b 为例：
x 为整型，结果都是整除;
x 为浮点型，a、b 有一个为浮点型，结果就是非整除，实际进行的也是非整除运算;
x 为浮点型，a、b 都是整型，结果为整除运算，实际进行的也是整除运算。

5、模运算
也叫求余运算，用 “%” 表示
操作数只能时以整型为基类型的数据，如整型、逻辑型、字符型、短整型、长整型，以及对应的无符号型等。
注：
若两个操作数中只有一个时负数，则结果依赖于计算机是随分子还是分母的符号。
若随分子，则向 0 一侧取整;
若随分母，则向 负无穷 一侧取整。
C++ 中模运算和除运算都随分子而定。
例：
21%-5 = 1
21/-5 = -4
-21%-5 = -1
-21/-5 = 4
-21%5 = -1
-21/5 = -4
21%5 = 1
21/5 = 4

6、自增、自减运算
++
--
既有计算，又有赋值。

二、逻辑运算符
与 &&
或 ||
非 !

三、关系运算符
> 大于
< 小于 == 等于 >= 大于等于
<= 小于等于
!= 不等于

注：
1、关系运算符两边的操作数类型必须相同，或者可以 隐式/显式 转换使其类型相同。
可以比较字符型和整型，因为字符型可以隐式转换为整型

2、关系运算符作用在不同类型上时，表现各不一样：
作用于整型：与数学上一样
作用于逻辑型：比较数字 0 与 1
作用于字符型：比较字符的 ASCII 码
作用于浮点型：最好不要用含等于的关系运算符，因为浮点型表示有误差。可以比较其差的绝对值是否小于某个较小数来判断其是否相等。
作用于指针型：指针类型必须相同，且只有当指针同时为空，或指向的地址相同时，才可称为比较相等
作用于结构体、共用体：要明确比较哪个成员，不能粗略地比较构造类型。

四、位运算
位运算是按二进制位进行运算，一般用来编需要直接控制硬件的程序。

1、按位与 &
两边操作数的对应位均为 1 时，结果位才为 1，否则为 0。
通常位运算会与一个称为掩码的整数一起使用，另一操作数被称为源操作数。通过设置不同的掩码，按位与可以用来执行如下操作：
清零指定位：将掩码中特定位置设为 0，其他位置设为 1，通过按位与运算，就可将操作数中指定的位置变为 0，而其他位不变。
取指定位：将掩码中的特定位置设为 1，其他位置设为 0，就可以取出操作数某一特定位的内容。取指定位可以用来测试某位的值。

2、按位或 |
操作数的对应位中只要有一个为 1，结果就为 1，否则为 0。
置 1 操作：将掩码的特定位置设为 1，其他位置设为 0，按位或可用来对源操作数的特定位置变为 1。

3、按位非 ~
对操作数按位求反，属于单目运算符。

4、按位异或 ^
按位进行异或运算，当操作数的对应位不相同时，才为 1，否则为 0。
将掩码的特定位置 1，其他位置 0，可将源操作数的特定位反转。
如果掩码全为 1，按位异或就变成了按位非;
如果掩码全为 0，按位异或就变成了复制;

5、按位左移 << 按位向左移若干位，左边的操作数从最高位开始向左移右操作数位，低位向高位移动，移出的高位丢弃，空出的低位补 0。 当移出的位不含 1 时，每左移 1 位，就相当于对左操作数作一次乘 2运算，因此，左移 n 位，就等同于 左操作数乘以2的n次方。 6、按位右移 >>
左边的操作数从最低位开始向右移右操作数位，高位向低位移动，移出的低位丢弃，
空出的高位：
若左操作数是有符号数，则空出的高位用符号位填充（算术右移），
若左操作数是无符号数，则用 0 填充（逻辑右移）。

当移出的位不含 1 时，每右移一位，就相当于对左操作数作一次除 2 运算，
因此，右移 n 位，等同于左操作数除以 2的n次方。

五、赋值
x+=y 功能上与 x=x+y 完全一样，但：
前者意指将某一块内存的值增加 y，后者是先将一个数字从内存块读出，计算 x+y，再将计算结果写入内存，
因此，前者比后者速度快。
