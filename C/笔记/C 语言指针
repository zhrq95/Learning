1、CPU 访问内存，是通过内存地址来读写内存数据的，CPU 与内存条硬件之间有个地址总线，CPU 通过地址总线将要访问/写入的内存地址告诉内存条。

2、对于 CPU 而言地址是唯一的读写内存的方式；

3、内存地址是一个整数；

4、应用程序使用的内存地址，其实不是真实的物理地址，而是操作系统映射好的虚拟的内存地址；如果直接操作真实的物理地址，一但操作失误就 GG 了；

5、32位系统的虚拟地址是由32位的二进制表示的；64位系统的虚拟地址是由64位的二进制表示的；VS默认编译的为32位的程序；

6、使用指针变量来访问以指针变量为数值的内存地址，必须要保证这个内存是符合逻辑的，没有越界的。

C 语言里使用 & 来获取变量的地址
任何一个变量（包括指针）都能通过 & 取得其内存地址。
例：
int a;
printf("a 的内存地址为：%d\n",&a);

C 语言里存放 内存地址数据 的 变量 就是指针
对于32位程序，指针变量的存储空间是 4 个字节（即一个32位的内存地址），
对于64位程序，指针变量的存储空间是 8 个字节（即一个64位的内存地址）。

指针的实质：指针存放的是一个地址数据，它本身是一个变量。

指针的定义：数据类型* 变量名称
表示这个变量存放的是所定义的数据类型的内存地址数据；
数据类型表示这个内存地址对应的变量的数据类型。

ptr 是一个 4 字节的变量，是可以给其赋值任意 int 型数据，但因为人为规定了 ptr 是指针，所以后面最好将其用来存放内存地址，若人为给其赋值，操作系统会将人为赋的值当作一个内存地址，而导致错误。
例：
int a =3;
int* ptr;
ptr = 3; //可以将 ptr 当作一个普通的 int 变量，用来存放 int 型数据 3，这样做会收到 warning
ptr = &a; //将指针 ptr 用来存放变量 a 的内存地址，指针（变量） ptr 和变量 a 是独立的。
ptr = &ptr; //将指针 ptr 用来存放变量 ptr 自己本身的内存地址

指针定义在哪里（局部？全局？），那么指针的内存就分配到哪里（栈？数据段？）

指针变量的初始化：
当指针定义在局部，如果不初始化，则这个指针存放的是一个不可预知的随机值。
当指针定义在全局，如果不初始化，则这个指针 默认初始化为 NULL。
int* ptr1 = NULL; //NULL 作为一个非法的地址用以作为判断区分，如果某个指针为 NULL，则表示这个指针还未给其赋值，提醒编程人员这个指针还不可使用
int* ptr2 = &a;
注：
0 也是一个内存地址，这个地址操作系统不允许程序去读写。

利用地址数据来取得地址里面的数据内容：
方法一：
1、取得指针变量里面存放的内存地址的数据
2、CPU 使用这个地址去访问内存，然后得到数据
例：
*ptr; //从 ptr 这个变量取出地址数据，然后从这个地址开始向后读取共 4 个字节（如果这个指针指向的变量的数据类型是 double 则为 8 个字节）的数据。
方法二：
使用指针变量存放的地址为基地址，然后外加一个偏移量来访问数据。
例：
ptr[0]，取得以这个地址为基地址。
ptr[1]，取得以这个地址为基地址的第 1 个元素，元素占用的字节根据指针指向的变量的数据类型来。

指针变量的加、减运算
ptr+=2：等价于 ptr=ptr+2*sizeof(数据类型)：存放的是下2个元素的起始地址，元素的字节大小是由指针对应的数据类型来决定。

void* 指针
表示这个指针只存放一个内存地址，没有任何数据类型，不能用它来访问，因为它是一个不确定的数据类型，CPU不知道要读取多少长度的内存条上的数据。
例：void* ptr = &a

指针与数组
1、数组是存放同一种类型的元素的数据集合，在 C 语言里数组的起始地址为数组的名称。
例：
int a[4];
printf("%d\n",a); //方法一，打印出这个数组开始的内存地址
printf("%d\n",&a[0]); //方法二， 打印出这个数组开始的内存地址

总结：
1、指针就是一个4字节（32位程序）或8字节（64位程序）的变量；
2、指针里面存放的是一个确定的编程人员可以掌握的内存地址；
3、要注意指针里面存储的内存地址的合法性、范围大小。